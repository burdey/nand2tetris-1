2.5.3と4.4〜5章は問題をほぼ解かなかったので、 (広義) **読んだ詐欺** です。

読んだ期間は2017年4月から2018年4月で、1年。ただしかなり読むのを放棄した期間があるので実質半年強ぐらいだと思う。
リポジトリはこちら
https://github.com/ryo0/sicp

## 所要時間の内訳（分単位で記録があるが適当に四捨五入してる）
<dl>
  <dt>
    1章
  </dt>
  <dd>
    29時間
  </dd>
  <dt>
    1章2周目
  </dt>
  <dd>
    12時間
  </dd>
  <dt>
    2章
  </dt>
  <dd>
    60.5時間
  </dd>
  <dt>
    3章
  </dt>
  <dd>
    62.5時間
  </dd>
  <dt>
    4章
  </dt>
  <dd>
    54.5時間
  </dd>
  <dt>
    5章
  </dt>
  <dd>
    17.7時間
  </dd>
</dl>

上にも書いたとおり、2.5.3はまるごとスキップし、4.4と5は問題飛ばしてます。あとちょっとした休憩時間などは省いてます。
更に具体的にどの問題に何分かかったのかは、SICPリポジトリの「所要時間」に書いてます。

## 読む上で知っておいたほうが良いこと
一人で読む場合孤独かつ長い戦いになるので、たくさんあるSICP読書ブログを読みながらモチベーションを維持した方がいい。本文のコードを動かす上での詰まりどころが何箇所かあるが、そういうときもブログがあると助かる。
いきなりSICP読むのが不安という人はScheme手習いを読んでおくといいかもしれないが、再帰がある程度わかる人なら読まなくても問題ないと思う。
数学は高校数学がわかっていれば十分だと思う。どうしても数学わからないという人は数学使う問題は飛ばせばいいと思う。
訳は真鍋さんの一択。
Lispの括弧支援プラグインが各エディタにあるので、入れることを強く勧める。
PareditというS式操作支援プラグインがあり、それも覚えたほうがいい。実質覚えたコマンドは2つぐらいだったがそれでも十分役立った。
Racketを使う場合はsicpライブラリを入れよう。ところどころで必須になる。
デバッグはRacketのtraceライブラリとdebugライブラリを覚えておけば4章含め戦える。
condは[]が使える。これは早くに知っておきたかった。
https://docs.racket-lang.org/reference/if.html
2章の最後の方、 `drop` と `raise` という名前の関数を実装させる問題があるが、組み込みでこの名前が付いた関数があり衝突（というか混合？）するので気をつけた方がいい。
4.1のインタプリタ `eval` も同様。` _eval` とリネームする事を勧める。

## SICPで得られたもの
以下は4章を読み終えた当時に書いた文章
念の為書いておくが、「木構造再帰」とデータ構造の木構造の再帰はまた別物。

```
一言で言うと、SICPは「プログラミング学」の本だと思う。
そういう言葉があるのか知らないけど、それ以外に適切な表現が思いつかない。

全体を通して
膨大な問題によって、プログラムの正しい読み方と適切な書き方が身に付いた、と思う。
あと、とんでもなく時間がかかったが、やりきった（厳密にはまだだが）ことで集中力と自信が付いた気がする。

1章
普通の再帰と反復再帰（末尾再帰）と木構造再帰の違い、及びそれぞれの広がり方、組み立て方、それぞれの時間計算量と空間計算量の違い・見積もり方
「手続きの抽象化」の意味と方法（DRY原則の一つの形なのかな、と思う）
高階関数の基礎
簡単なプログラムの実行モデルの脳内構築
数式や数学的手法をコードに落とし込む方法

2章
データの抽象化（生データは晒さずに抽象的で理解しやすいインターフェイスだけを晒す。多分オブジェクト指向における基礎に繋がる事）
リストと木の再帰
リストにおける高階関数（データを次々に処理する、いわゆるデータフロー）
データと手続きがある構造（要はクラス）において、データ・手続きが新たに追加されていく場合の
データ主導・メッセージパッシング・明確な振り分け、
という3つの異なる手法の存在、及びそれぞれのメリット・デメリット

3章
破壊的代入によりどのように表現力が変化するか、
及び、よく言われる「破壊的代入がプログラムの動作を予想しづらくする」という言葉の意味
（計算順序によって結果が変化するコード、並列処理、メモ化したストリームにおける挙動で学び、実感としてはっきり理解できた）
破壊的代入を導入した場合におけるプログラムの動作モデルとその複雑さ（上のと繋がる。動作モデルが複雑だからこそ挙動が複雑と言えるので）
可変データによる可変な状態を持つ対象のモデル化
モジュール化の基礎
並列プログラミングの概要とその難しさ
無限ストリーム（遅延リスト）という新たなパラダイムと、その圧倒的な表現力、そして無限ストリームを駆使しても尚並列プログラミングは難しいということ
（個人的にSICPで最も感動したのは無限ストリーム。非常に簡単に実装できて概念自体もシンプルなのに、驚くほど表現力が高まるという感動）

4章全体
インタプリタというとっておきの題材を通してこれまで見てきた様々な概念を改めて深く考え直す事が出来た。
また、インタプリタ（あるいは言語それ自体）と言えど理解可能なプログラムの一つだと理解出来た。
「すべてのプログラムはある種の評価器」という発想には至れなかったが、
2章の記号微分が最初の簡単なインタプリタの例であることに気付けた。
4章を読み終えた後に記号微分の問題を解いてみたら非常に簡単に解けるようになっていた。
4.1
インタプリタが実際にどのように実装されているかを見ることによって、
プログラムの動作モデルについて今までより深い理解を得た。
特に3章で意味不明だった環境モデルについて確かな理解が出来るようになった。
構文（ifとか）と手続きの違いを実装レベルで理解できた。
あと、4.1のメタ循環評価器についてはほぼ完全にコードの動きをトレースする事が出来て、自信につながった。
4.2
上手く言えないが、3.5とは違う実装方法による遅延評価パラダイムによって新しい視点を得た気がする
4.3
非決定性計算という新しいパラダイムにおける新たな世界のモデル化法、及びその表現力
そしてその実装を通じて複雑な機能にも理解可能な裏側がある事を知った。
継続については既にある程度Scheme手習いとScheme修行で知っているつもりだったが、
ここまで複雑な継続の使い方は知らなかったので、その点も勉強になった
4.4
殆ど飛ばしたので、上手く言えないが、
4.3同様新しいパラダイムによる異なる世界のモデル化法（捉え方）を知れた感じはある。
実装は概要しか見てないのでなんとも。
```

## SICPでは扱っていなかったプログラミングの重要事項
筆者自身まだ出来ていないが、オブジェクト指向とデザインパターンとかアルゴリズムとデータ構造とかしっかり学ばないとこれ読んでもどうしようもないコードしか書けないなあと思う
あと5章を通してレジスタマシンのレベルにまでさかのぼってプログラムの動作原理を掘り下げるということをやっているが、IOについての説明は完全に放棄している。
コンピュータとプログラムの仕組みを根っこから知りたい、という動機を完全に果たしたいなら結局OSについても学ぶ必要があるのかなあと思うしそこはSICPが残した宿題感があった。

## SICPの好きな所
題材が面白い。ニュートン法、多項式の微分、エイト・クイーン問題、型と型変換の実装、デジタル回路シミュレータ、無限ストリーム、インタプリタ、レジスタマシンシミュレータなど、どれも読者の興味を駆り立てる題材ばかり扱っている。
そして問題の難易度もかなりちょうどいい。本文を読んでいれば手も足も出ないという問題はあまりなかった。一部難問や超難問が紛れているが全部解ける人はそうそういないはずなので割り切って解けるものだけ解くようにするのがモチベーション面で大事だと思う。
感覚的には、CheckIOというオンラインジャッジサイトをやってた時のような感覚で解き進めることが出来た。最後の方で結局息切れして問題は飛ばしたのだけど、とにかくゲーム感覚で解ける本だった。
SICP+問題番号でググると大勢が解いているので答え合わせが簡単にできるところもいい。

## SICPのいやな所
この本の前にOCamlを少し学んでいたのでどうしてもOCamlと比較してScheme(Lisp)の嫌なところばかり目についた。（Lispだから出来た本ではあるし、比較するなと言われそうだが）
デバッグの苦しみの何割かは型があればどうにかなったと思うが、それ以上にS式シンタックスに慣れるのに非常に時間がかかり苦しんだ。
括弧の対応ミスがなくなり無意識に合わせられるようになったのは2章の最後のほうだが、この前に読んだScheme手習いとScheme修行を合わせれば余裕で100時間以上かかっている。1章の慣れない間は括弧が合わないという理由で解くのを断念した問題があったぐらいで、かなり括弧はやっかいだった。
そしてすべてのデータ構造を連結リストの入れ子で作るのも、かなりイライラ。代数的データ型とパターンマッチを知った後だと「なんでこんなことを？」と思ってしまう。（調べるとRacketにパターンマッチはちゃんとあるそうなので、これはSICP特有なのかもしれないが。）

## SICPのあと
とりあえずプログラミング in OCamlとかLand of LispとかNand2Tetrisとかいろいろ読みたい本があるので読みたい。
SICP読み終えて結構経つものの未だに読んだことでどれだけ実力が付いたのか自分でもよくわかってないところがある（再帰は呼吸にはなったが）ので、成長を実感したい。
他にもプログラマとして抑えとくべきことが当然無数にあり、これに1年かけた事で出遅れた部分がかなりあるのでなんとかしたい。
